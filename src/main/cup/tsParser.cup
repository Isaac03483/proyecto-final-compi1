package com.mio.typeSecure.compiler.parser;

import com.mio.typeSecure.compiler.Token;
import com.mio.typeSecure.compiler.lexer.TSLexer;
import com.mio.typeSecure.models.TSError;
import java_cup.runtime.Symbol;
import java.util.ArrayList;
import java.util.List;
import com.mio.typeSecure.instructions.*;

class TSParser;
/*
 java -jar java-cup-11b.jar /home/mio/Escritorio/2023/proyecto-final-compi1/src/main/cup/tsParser.cup
*/
parser code {:

    private List<TSError> errorList;
    public List<Instruction> instructions;
    public TSParser(List<Instruction> instructions, TSLexer lexer, List<TSError> errorList){
        super(lexer);
        this.errorList = errorList;
        this.instructions=instructions;

    }

    public Symbol scan() throws Exception {
        Symbol symbol = this.getScanner().next_token();
        if (symbol == null) {
            return this.getSymbolFactory().newSymbol("END_OF_FILE", this.EOF_sym());
        }

        while(symbol != null && symbol.sym == TSParserSym.SYM) {
            this.report_expected_token_ids();
            Token token = (Token) symbol.value;
            errorList.add(
                new TSError(token.line(), token.column(), "El simbolo: "+token.value()+" no forma parte del lenguaje.")
            );
            symbol = this.getScanner().next_token();
        }

        if (symbol == null) {
            return this.getSymbolFactory().newSymbol("END_OF_FILE", this.EOF_sym());
        }

        return symbol;
    }

    public void report_error(String message, Object info) {
        System.out.println("public void report_error");
    }

    public void report_fatal_error(String message, Object info) {
        System.out.println("public void report_fatal_error");
    }

    public void syntax_error(Symbol cur_token) {
        Token token = (Token) cur_token.value;


        if (cur_token.sym == TSParserSym.EOF) {
            errorList.add(new TSError(token.line(), token.column(), "Simbolo no esperado."));

        } else {
            String tokenVal = token.value() == null? TSParserSym.terminalNames[token.type()]: token.value();
            errorList.add(new TSError(token.line(), token.column(), "Simbolo no esperado: "+tokenVal));

        }
    }

    public void unrecovered_syntax_error(Symbol cur_token) {
        Token token = (Token) cur_token.value;

        if (cur_token.sym == TSParserSym.EOF) {
            errorList.add(new TSError(token.line(), token.column(), "Simbolo no esperado."));

        } else {
            String tokenVal = token.value() == null? TSParserSym.terminalNames[token.type()]: token.value();
            errorList.add(new TSError(token.line(), token.column(), "Simbolo no esperado: "+tokenVal));


        }
    }
:}


terminal Token INCREMENT, DECREMENT, PLUS, MINUS, TIMES, DIVIDE, MOD, LPAREN, RPAREN, COLON, SEMICOLON;
terminal Token EQUALS, NOT_EQUALS, NOT, GREATER_EQ, LESS_EQ, LESS, GREATER, ASSIGN, AND, OR, COMMA, DOT;
terminal Token LBRACE, RBRACE, TRUE, FALSE, NUMBER, BIGINT, STRING, BOOLEAN, VOID, UNDEFINED, CONST, LET;
terminal Token NUMBER_FUN, BIGINT_FUN, STRING_FUN, BOOLEAN_FUN, LENGTH, CHAR_AT, LOWER, UPPER, CONCAT;
terminal Token CONSOLE_LOG, IF, ELSE, FOR, WHILE, DO, BREAK, CONTINUE, FUNCTION, RETURN, E, PI, SQRT_TWO;
terminal Token ABS, CEIL, COS, SIN, TAN, EXP, FLOOR, POW, SQRT, RANDOM, ID, NUMBER_VALUE, BIGINT_VALUE;
terminal Token STRING_VALUE, SYM, PRINT_AST, SYMBOL_TABLE;

non terminal List<Instruction> main,instructions,ids;
non terminal List<Parameter> parameters;
non terminal Parameter parameter;
non terminal VariableType type;
non terminal Instruction funInstruction,instruction;
non terminal Instruction declarationInstruction, assignmentInstruction, ifInstruction, forInstruction, whileInstruction;
non terminal Instruction doWhileInstruction,elseIfInstruction,assignmentInDec,declarationList,varType;
non terminal Instruction idType,inDecInstruction, callFunction,consoleInstruction,a,b,c,d,w,x,y,z;
non terminal Instruction continueInstruction, breakInstruction, returnInstruction, mathFun, mathConst;
non terminal ReturnType returnType;
non terminal StringInstruction stringFun;
non terminal Token castFun;

start with main;


main
::= instructions:list
    {:RESULT = list;:}
	;
	
instructions
::=	instructions:list instruction:instruction
    {:RESULT = list; RESULT.add(instruction);:}
    |
    {:RESULT = this.parser.instructions;:}
	;
	
parameters
::=	parameters:list COMMA parameter:p
    {:RESULT = list; RESULT.add(p);:}
	| parameter:p
	{:RESULT = new ArrayList<>(); RESULT.add(p);:}
	;
	
parameter
::=	ID:id COLON type:variableType
    {:RESULT = new Parameter(id.value(), variableType);:}
	;
	
type
::=	NUMBER
	{:RESULT = VariableType.NUMBER;:}
	| BIGINT
	{:RESULT = VariableType.BIG_INT;:}
	| STRING
	{:RESULT = VariableType.STRING;:}
	| BOOLEAN
	{:RESULT = VariableType.BOOLEAN;:}
	;
	

	
instruction
::=	declarationInstruction SEMICOLON
    | funInstruction
	| assignmentInstruction SEMICOLON
	| ifInstruction
	| forInstruction
	| whileInstruction
	| doWhileInstruction
	| inDecInstruction SEMICOLON
	| callFunction SEMICOLON
	| consoleInstruction SEMICOLON
	| continueInstruction SEMICOLON
	| breakInstruction SEMICOLON
	| returnInstruction SEMICOLON
	| error SEMICOLON
	;

funInstruction
::=	FUNCTION ID LPAREN parameters RPAREN returnType LBRACE instructions RBRACE
	| FUNCTION ID LPAREN RPAREN returnType LBRACE instructions RBRACE
	;

returnType
::= COLON VOID
    | COLON NUMBER
    | COLON BIGINT
    | COLON STRING
    | COLON BOOLEAN
    |
    ;
	
	
ifInstruction
::=	IF LPAREN w RPAREN LBRACE instructions RBRACE
	| IF LPAREN w RPAREN LBRACE instructions RBRACE elseIfInstruction
	;
	
elseIfInstruction
::=	ELSE ifInstruction
	| ELSE LBRACE instructions RBRACE
	;

forInstruction
::=	FOR LPAREN declarationInstruction SEMICOLON w SEMICOLON assignmentInDec RPAREN LBRACE instructions RBRACE
	| FOR LPAREN assignmentInstruction SEMICOLON w SEMICOLON assignmentInDec RPAREN LBRACE instructions RBRACE
	;

assignmentInDec
::= inDecInstruction
    | assignmentInstruction
    ;

inDecInstruction
::=	| ID INCREMENT
	| ID DECREMENT
	;

whileInstruction
::=	WHILE LPAREN w RPAREN LBRACE instructions RBRACE
	;
	
doWhileInstruction
::=	DO LBRACE instructions RBRACE WHILE LPAREN w RPAREN SEMICOLON
    ;
	
declarationInstruction
::=	varType declarationList
	;
	
declarationList
::=	declarationList COMMA ID idType ASSIGN w
	| declarationList COMMA ID idType
	| ID idType
	| ID idType ASSIGN w
	;
	
idType
::=	COLON type
	|
	;
	
varType
::=	LET
	| CONST
	;
	
assignmentInstruction
::=	ID ASSIGN w
	;

callFunction
::= ID:id LPAREN ids:ids RPAREN
    {:RESULT = new CallFunction(id.line(), id.column(), id.value(), ids);:}
    | ID:id LPAREN RPAREN
    {:RESULT = new CallFunction(id.line(), id.column(), id.value(), null);:}
    | mathFun:math
    {:RESULT = math;:}
    ;

ids
::= ids:list COMMA w:val
    {:RESULT = list; RESULT.add(val);:}
    | w:val
    {:RESULT = new ArrayList<>(); RESULT.add(val);:}
    | error COMMA
    ;

consoleInstruction
::= CONSOLE_LOG:console LPAREN ids:ids RPAREN
    {:RESULT = new ConsoleLog(console.line(), console.column(), ids);:}
    | error RPAREN
    ;

continueInstruction
::= CONTINUE:cont
    {:RESULT = new Continue(cont.line(), cont.column());:}
    ;

breakInstruction
::= BREAK:brk
    {:RESULT = new Break(brk.line(), brk.column());:}
    ;

returnInstruction
::= RETURN:rtn
    {:RESULT = new ReturnInstruction(rtn.line(), rtn.column(), null);:}
    | RETURN:rtn w:val
    {:RESULT = new ReturnInstruction(rtn.line(), rtn.column(), val);:}
    ;

w
::=	w OR x
	| x
	;
	
x
::=	x AND y
	| y
	;

y
::= NOT z
    | z:val
    {:RESULT = val;:}
    ;

z
::=	z EQUALS a
	| z NOT_EQUALS a
	| z LESS a
	| z GREATER a
	| z LESS_EQ a
	| z GREATER_EQ a
	| a:val
	{:RESULT = val;:}
	;
	
a
::=	a PLUS b
	| a MINUS b
	| b:val
	{:RESULT = val;:}
	;
	
b
::=	b:lft TIMES:tm c:rgt
	{:RESULT = new BinaryOperation(tm.line(),tm.column(), lft, rgt, OperationType.TIMES);:}
	| b:lft DIVIDE:dv c:rgt
	{:RESULT = new BinaryOperation(dv.line(),dv.column(), lft, rgt, OperationType.DIVIDE);:}
	| b:lft MOD:md c:rgt
	{:RESULT = new BinaryOperation(md.line(),md.column(), lft, rgt, OperationType.MOD);:}
	| c:val
	{:RESULT = val;:}
	;

c
::=	castFun:cast LPAREN w:val RPAREN
    {:
    switch(cast.type()){
        case TSParserSym.NUMBER_FUN -> {
            RESULT = new Cast(cast.line(), cast.column(), val, CastType.CAST_NUM);
        }
        case TSParserSym.BIGINT_FUN -> {
            RESULT = new Cast(cast.line(), cast.column(), val, CastType.CAST_BIG);
        }
        case TSParserSym.BOOLEAN_FUN -> {
            RESULT = new Cast(cast.line(), cast.column(), val, CastType.CAST_BOOL);

        }
        case TSParserSym.STRING_FUN -> {
            RESULT = new Cast(cast.line(), cast.column(), val, CastType.CAST_STRING);

        }

    }
    :}
	| d:d
	{:RESULT = d;:}
	;
	
d
::=	NUMBER_VALUE:number
	{:RESULT = new Value(number.line(), number.column(), number.value(), ValueType.NUMBER_VALUE);:}

	| BIGINT_VALUE:bigInt
	{:RESULT = new Value(bigInt.line(), bigInt.column(), bigInt.value(), ValueType.BIG_INT_VALUE);:}

	| TRUE:trueVal
	{:RESULT = new Value(trueVal.line(), trueVal.column(), "true", ValueType.BOOLEAN);:}

	| FALSE:falseVal
	{:RESULT = new Value(falseVal.line(), falseVal.column(), "false", ValueType.BOOLEAN);:}

    | STRING_VALUE:value DOT stringFun:stringFun
	{:stringFun.setValue(value.value()); RESULT = stringFun;:}

	| STRING_VALUE:string
	{:RESULT = new Value(string.line(), string.column(), string.value(), ValueType.STRING_VALUE);:}

	| ID:id
	{:RESULT = new Value(id.line(), id.column(), id.value(), ValueType.ID);:}

	| ID:value DOT stringFun:stringFun
	{:stringFun.setValue(value.value()); RESULT = stringFun;:}

	| callFunction:callFunction
	{:RESULT = callFunction;:}

	| mathConst:math
	{:RESULT = math;:}

	| LPAREN a:val RPAREN
	{:RESULT = val;:}
	;
	
castFun
::=	NUMBER_FUN:nbr
	{:RESULT = nbr;:}
	| BIGINT_FUN:bg
	{:RESULT = bg;:}
	| STRING_FUN:st
	{:RESULT = st;:}
	| BOOLEAN_FUN:bl
	{:RESULT = bl;:}
	;
	
stringFun
::=	LENGTH
	| CHAR_AT LPAREN a RPAREN
	| LOWER LPAREN RPAREN
	| UPPER LPAREN RPAREN
	| CONCAT LPAREN a RPAREN
	| error RPAREN
	;

mathFun
::= ABS:bs LPAREN ids:ids RPAREN
    {:RESULT = new MathInstruction(bs.line(), bs.column(), MathType.ABS, ids);:}
    | CEIL:cl LPAREN ids:ids RPAREN
    {:RESULT = new MathInstruction(cl.line(), cl.column(), MathType.CEIL, ids);:}
    | COS:cs LPAREN ids:ids RPAREN
    {:RESULT = new MathInstruction(cs.line(), cs.column(), MathType.COS, ids);:}
    | SIN:sn LPAREN ids:ids RPAREN
    {:RESULT = new MathInstruction(sn.line(), sn.column(), MathType.SIN, ids);:}
    | TAN:tn LPAREN ids:ids RPAREN
    {:RESULT = new MathInstruction(tn.line(), tn.column(), MathType.TAN, ids);:}
    | EXP:xp LPAREN ids:ids RPAREN
    {:RESULT = new MathInstruction(xp.line(), xp.column(), MathType.EXP, ids);:}
    | FLOOR:fr LPAREN ids:ids RPAREN
    {:RESULT = new MathInstruction(fr.line(), fr.column(), MathType.FLOOR, ids);:}
    | POW:pw LPAREN ids:ids RPAREN
    {:RESULT = new MathInstruction(pw.line(), pw.column(), MathType.POW, ids);:}
    | SQRT:srt LPAREN ids:ids RPAREN
    {:RESULT = new MathInstruction(srt.line(), srt.column(), MathType.SQRT, ids);:}
    | RANDOM:rm LPAREN RPAREN
    {:RESULT = new MathInstruction(rm.line(), rm.column(), MathType.RANDOM, null);:}

    ;

mathConst
::= E:e
    {:RESULT = new MathInstruction(e.line(), e.column(), MathType.E, null);:}
    | PI:pi
    {:RESULT = new MathInstruction(pi.line(), pi.column(), MathType.PI, null);:}
    | SQRT_TWO:sqrt
    {:RESULT = new MathInstruction(sqrt.line(), sqrt.column(), MathType.SQRT_TWO, null);:}
    ;

